---
title: Backwards compatibility of Kotlin default arguments
date: "2021-02-28"
published: true
tags: [kotlin]
cover_image: blog-card.png
---

Kotlin's default arguments can make a library's APIs easier to understand as a user and easier to write as the library's developer. No more manually writing out function overloads with every possible useful combination of arguments. Furthermore, when reading these functions its easy to see what arguments can be left out and what values they use if you do.

That all sounds great, right? For most use-cases of Kotlin default arguments will work and there won't be any issues, bar any bad code you write but that isn't really Kotlin's fault. However for other use cases, there is a flaw with how default arguments work. More precisely evolving the API of a library, framework or platform without requiring existing code to recompile.

This post will focus on how Kotlin's default arguments work under the hood, why that affects backwards compatibility and what can be done about it.

## How default arguments work

Kotlin's default arguments allow you to write a function like:

```kotlin
interface MyInterface {

  fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E())
}
```

Where the caller of the function can decide which arguments it cares about providing values for and relying on the defaults for the rest. You can find a _little_ bit more information on this in the [Kotlin docs](https://kotlinlang.org/docs/functions.html#default-arguments).

That's what happens at a high level, for most people writing and using Kotlin code that is all you'll really need. However, to really understand how this can affect backwards compatibility we'll need to take a closer look. To do this, we'll take a look at the generated bytecode.

Below is the Kotlin bytecode generated from the function shown previously (large code snippet incoming!):

```java
// ================dev/lankydan/api/MyInterface$DefaultImpls.class =================
// class version 50.0 (50)
// access flags 0x31
public final class dev/lankydan/api/MyInterface$DefaultImpls {


  // access flags 0x1009
  public static synthetic function$default(Ldev/lankydan/api/MyInterface;Ldev/lankydan/api/MyInterface$A;Ldev/lankydan/api/MyInterface$B;
  Ldev/lankydan/api/MyInterface$C;Ldev/lankydan/api/MyInterface$D;Ldev/lankydan/api/MyInterface$E;ILjava/lang/Object;)V
    ALOAD 7
    IFNULL L0
    NEW java/lang/UnsupportedOperationException
    DUP
    LDC "Super calls with default arguments not supported in this target, function: function"
    INVOKESPECIAL java/lang/UnsupportedOperationException.<init> (Ljava/lang/String;)V
    ATHROW
   L0
    ILOAD 6
    ICONST_1
    IAND
    IFEQ L1
   L2
    LINENUMBER 5 L2
    NEW dev/lankydan/api/MyInterface$A
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$A.<init> ()V
    ASTORE 1
   L1
    ILOAD 6
    ICONST_2
    IAND
    IFEQ L3
    NEW dev/lankydan/api/MyInterface$B
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$B.<init> ()V
    ASTORE 2
   L3
    ILOAD 6
    ICONST_4
    IAND
    IFEQ L4
    NEW dev/lankydan/api/MyInterface$C
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$C.<init> ()V
    ASTORE 3
   L4
    ILOAD 6
    BIPUSH 8
    IAND
    IFEQ L5
    NEW dev/lankydan/api/MyInterface$D
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$D.<init> ()V
    ASTORE 4
   L5
    ILOAD 6
    BIPUSH 16
    IAND
    IFEQ L6
    NEW dev/lankydan/api/MyInterface$E
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$E.<init> ()V
    ASTORE 5
   L6
    ALOAD 0
    ALOAD 1
    ALOAD 2
    ALOAD 3
    ALOAD 4
    ALOAD 5
    INVOKEINTERFACE dev/lankydan/api/MyInterface.function (Ldev/lankydan/api/MyInterface$A;Ldev/lankydan/api/MyInterface$B;Ldev/lankydan/api/MyInterface$C;Ldev/lankydan/api/MyInterface$D;Ldev/lankydan/api/MyInterface$E;)V (itf)
    RETURN
    MAXSTACK = 6
    MAXLOCALS = 8

  @Lkotlin/Metadata;(mv={1, 4, 1}, bv={1, 0, 3}, k=3)
  // access flags 0x19
  public final static INNERCLASS dev/lankydan/api/MyInterface$DefaultImpls dev/lankydan/api/MyInterface DefaultImpls
  // compiled from: MyInterface.kt
}
```

It's quite likely that most of this doesn't make sense. I'm not trying to be patronising, I also don't _really_ know how to read Kotlin/Java/JVM bytecode but we can still extract some information from it.

Firstly, an alternative version of `MyInterface` was generated, `dev/lankydan/api/MyInterface$DefaultImpls`. I haven't shown all the bytecode, but if I did you would see `dev/lankydan/api/MyInterface` does exist and is separate from the _default_ version.

Secondly, a `synthetic` function was placed inside the previously mentioned `MyInterface$DefaultImpls` with arguments that don't exactly match those of the original version in `MyInterface`. If you look more carefully, you'll notice that the first argument is an instance of `MyInterface` and is followed by the same arguments defined in the Kotlin function. Although that is not entirely true, there are two extra arguments, an `int` and an `Object` (this can be seen in `ILjava/lang/Object;` where the `I` represents the `int` and `Ljava/lang/Object` speaks for itself).

The next question is why are these last two arguments there.

If you can understand the bytecode above, then maybe you've been able to figure out why they're there. For the rest of us mortal beings though, I have added the decompiled version that shows it as Java code below:

```java
public static final class DefaultImpls {
  // $FF: synthetic method
  public static void function$default(MyInterface var0, MyInterface.A var1, MyInterface.B var2, 
  MyInterface.C var3, MyInterface.D var4, MyInterface.E var5, int var6, Object var7) {
    if (var7 != null) {
      throw new UnsupportedOperationException("Super calls with default arguments not supported in this target, function: function");
    } else {
      if ((var6 & 1) != 0) {
        var1 = new MyInterface.A();
      }

      if ((var6 & 2) != 0) {
        var2 = new MyInterface.B();
      }

      if ((var6 & 4) != 0) {
        var3 = new MyInterface.C();
      }

      if ((var6 & 8) != 0) {
        var4 = new MyInterface.D();
      }

      if ((var6 & 16) != 0) {
        var5 = new MyInterface.E();
      }

      var0.function(var1, var2, var3, var4, var5);
    }
  }
}
```

From this version, we can now see how the `int` and `Object` are being used.

- The `Object` - From what I could find out, the `Object` is not actually used as yet. Suposidly, this `Object` will be used for adding `super` calls with default values some time in the future. Here are a few links that indicate this - [StackOverflow](https://stackoverflow.com/questions/39733830/default-arguments-vs-overloads-when-to-use-which/39748921#39748921), [StackOverflow](https://stackoverflow.com/questions/39733830/default-arguments-vs-overloads-when-to-use-which/39748921#39748921) and [Jetbrains' YouTrack](https://youtrack.jetbrains.com/issue/KT-15414) (currently 4 years old).

- The `int` - Determines which arguments use their default values. This is done by executing a bitwise AND (`&`) against the `int` and number increasing in powers of 2 (to represent binary numbers with a leading 1, e.g. 2 = `10` and 16 = `10000`). The `int` itself is determined by the call-site depending on which arguments are passed into the function. For example:

  ```kotlin
  // Kotlin call-site
  myInterface.function(b = MyInterface.B(), c = MyInterface.C())
  ```

  ```java
  // Decompiled code of the call-site
  DefaultImpls.function$default(myInterface, (A)null, new B(), new C(), (D)null, (E)null, 25, (Object)null);
  ```

  The compiler determines that 25 (`11001`) will be passed in. Let's quickly do the bitwise operations to see which default values are used, I've also put an example below and a link to [Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation) incase you're interested in how the bitwise AND works (I haven't linked to Wikipedia for a while!):

  ```
  11001 AND
  00001
  -----
  00001 = 1
  ```

  Below are the operations matching the decompiled code:

  - `25 & 1` = 1
  - `25 & 2` = 0
  - `25 & 4` = 0
  - `25 & 8` = 1
  - `25 & 16` = 1

  These results match up to what we expect. The decompiled code shows that if the result of the bitwise AND returns anything other than 0, then a default value will be supplied. For the call-site above, this means that `A`, `D` and `E` all receive default values, which correctly matches the Kotlin code.

Finally, as seen in the decompiled code, now that all the `var(n)`s are set (with passed in or default values) they are passed into the _real_ function. Thus reaching the end of the process.

Hopefully that all made sense, if not, give it another read. If it still doesn't then you can blame me for failing to explain it well enough. Anyway, we will need this knowledge in the next section to understand how Kotlin's default arguments affect backwards compatibility.

## Why this affects backwards compatibility

First I'll define what I mean as "backwards compatibility". I quite liked how [Wikipedia](https://en.wikipedia.org/wiki/Backward_compatibility) stated it, so I'll put that below:

> Backward compatibility (also known as backwards compatibility) is a property of a system, product, or technology that allows for interoperability with an older legacy system, or with input designed for such a system, especially in telecommunications and computing.

In terms of what I am writing about, it means that a library, framework or platform should be able to evolve and release new versions without breaking existing code. 

More precisely for this post, that a function with default arguments can evolve without breaking existing usages of the function.

We will use the code from before and explore what happens as we evolve the interface's function, added again since it's so far away now:

```kotlin
interface MyInterface {

  fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E())
}
```

While keeping the call-site the same as it represents "existing code":

```kotlin
myInterface.function(b = MyInterface.B(), c = MyInterface.C())
```

Before I continue, I want to point out that removing an argument or adding a new one that does not have a default value from an existing function will never be backwards compatible. 

```kotlin
// Removing an argument
âŒ fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D())
// Adding an argument without a default value
âŒ fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E(), f: F)
```

You are guaranteed to break existing code if you do that. The only way to do this without breaking anything is to add an overload with the change in arguments. As this post is focusing on default arguments I won't explain through these two scenarios any further.

By excluding basic removing and adding, we are left with adding a new argument that comes with a default value. This scenario is different from adding a new one without a default value, because existing callers of the function _should_ work. These callers will still be using the previous version of the function and that's ok due to their reliance on default values for missing arguments. Therefore the function's new argument is not enough to break these applications.

```kotlin
// Adding an argument with a default value
âœ… fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E(), f: F = F())
```

But, and a big but ðŸ˜, the existing code will __only__ continue to work if it is __recompiled__. 

Now, this is ok in a lot of situations. If you are using a library or framework and you update them, then you will most likely recompile your project as your application is what starts everything and therefore cannot benefit from the updates without a rebuild. 

However, if you are using something that resembles a platform, that runs you application rather than the other way around, then your application should still work without recompilation. This is where the inner workings of Kotlin's default arguments unravel.

> An analogy for this is, when your operating system updates you don't want to also update every application on your machine. Instead you want them to continue working as they were with the possibility of updating to benefit from specific improvements that were made.

To understand why it breaks without recompilation, we need to look at the decompiled bytecode of the function and call-site again:

```java
// Decompiled code of the function with default arguments
public static void function$default(MyInterface var0, MyInterface.A var1, MyInterface.B var2, 
  MyInterface.C var3, MyInterface.D var4, MyInterface.E var5, int var6, Object var7)
```

```java
// Decompiled code of the call-site
DefaultImpls.function$default(myInterface, (A)null, new B(), new C(), (D)null, (E)null, 25, (Object)null);
```

Now we'll introduce the updated version with a new argument with a default value and take a look at the decompiled code:

```java
public static void function$default(MyInterface var0, MyInterface.A var1, MyInterface.B var2,
  MyInterface.C var3, MyInterface.D var4, MyInterface.E var5, MyInterface.F var6, int var7, Object var8)
```

> Note, that this is now the only version of the function in the bytecode.

Let's much up the old call-site with the function's new version:

| Call-site       | Extra argument  |    |
|-----------------|-----------------|----|
| `MyInterface`   | `MyInterface`   | âœ… |
| `MyInterface.A` | `MyInterface.A` | âœ… |
| `MyInterface.B` | `MyInterface.B` | âœ… |
| `MyInterface.C` | `MyInterface.C` | âœ… |
| `MyInterface.D` | `MyInterface.D` | âœ… |
| `MyInterface.E` | `MyInterface.E` | âœ… |
| `int`           | `MyInterface.F` | âŒ |
| `Object`        | `int`           | âŒ |
| -               | `Object`        | âŒ |

The call-site no longer passes in the correct inputs for the function. Trying to run the existing code against the updated function will cause the following error (nicely formatted to make it easier to read):

```java
Caused by: java.lang.NoSuchMethodError: 
'void dev.lankydan.api.MyInterface$DefaultImpls.function$default(
  dev.lankydan.api.MyInterface, 
  dev.lankydan.api.MyInterface$A,
  dev.lankydan.api.MyInterface$B,
  dev.lankydan.api.MyInterface$C,
  dev.lankydan.api.MyInterface$D, 
  dev.lankydan.api.MyInterface$E,
  int,
  java.lang.Object
)'
```

Ok, so we've seen what goes wrong when a new argument with a default value is added to a function without recompiling the code using it. Does this mean there is no hope? Stop worrying and read the next section!

## What can be done about it

The previous section showed why platform writers need to be careful adding new arguments with default values to existing functions. However I didn't detail any solutions, which I'll now rectify.

As mentioned previously, depending on the situation, recompiling the depending code might be the simplest solution. If that is a valid choice, I would probably just go with that. From now on though, we'll assume that it's not a good idea and consider how to keep everything working without recompilation.

Evolving the function without breaking anything will require a new overload. In the same way that I briefly mentioned removing or adding a non-default argument, this is the only choice you really have (I'll touch on a completely different choice in a second). 

```kotlin
// Original version
âœ… fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E())
// New overload with the extra argument
âœ… fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E(), f: F = F())
```

As shown earlier, you unfortunately cannot rely on the code to work without handling it yourself.

From a bytecode perspective this works because there will be a synthetic function for each overload. Keeping the original version around so that it can be used from existing applications.

A different choice to circumvent this problem is to not use default arguments at all. I know, that sounds odd, but one way to not fall into this trap is to stay on the well trodden path. In Java to evolve an API without breaking anything you would always use a new overload. It worked for Java, so why wouldn't it work for Kotlin. 

The obvious downside is that you lose the benefit of default values all together, but you'll have to decide what works best for you and stick to it. Maybe a rule of "no default arguments" is easier to follow that "always add an overload" even though the outcome is completely the same (for that singular change).

> You might have to include _a lot_ of overloads to keep the same functionality of default arguments.



## Why are the 2 args at the end there and not at the from (this of a heading)
