---
title: Backwards compatibility of Kotlin default arguments
date: "2021-02-28"
published: true
tags: [kotlin]
cover_image: blog-card.png
---

Kotlin's default arguments can make a library's APIs easier to understand as a user and easier to write as the library's developer. No more manually writing out function overloads with every possible useful combination of arguments. Furthermore, when reading these functions its easy to see what arguments can be left out and what values they use if you do.

That all sounds great, right? For most use-cases of Kotlin default arguments will work and there won't be any issues, bar any bad code you write but that isn't really Kotlin's fault. However for other use cases, there is a flaw with how default arguments work. More precisely evolving the API of a library, framework or platform without requiring existing code to recompile.

This post will focus on how Kotlin's default arguments work under the hood, why that affects backwards compatibility and what can be done about it.

## How default arguments work

Kotlin's default arguments allow you to write a function like:

```kotlin
interface MyInterface {

  fun function(a: A = A(), b: B = B(), c: C = C(), d: D = D(), e: E = E())
}
```

Where the caller of the function can decide which arguments it cares about providing values for and relying on the defaults for the rest. You can find a _little_ bit more information on this in the [Kotlin docs](https://kotlinlang.org/docs/functions.html#default-arguments).

That's what happens at a high level, for most people writing and using Kotlin code that is all you'll really need. However, to really understand how this can affect backwards compatibility we'll need to take a closer look. To do this, we'll take a look at the generated bytecode.

Below is the Kotlin bytecode generated from the function shown previously (large code snippet incoming!):

```java
// ================dev/lankydan/api/MyInterface$DefaultImpls.class =================
// class version 50.0 (50)
// access flags 0x31
public final class dev/lankydan/api/MyInterface$DefaultImpls {


  // access flags 0x1009
  public static synthetic function$default(Ldev/lankydan/api/MyInterface;Ldev/lankydan/api/MyInterface$A;Ldev/lankydan/api/MyInterface$B;
  Ldev/lankydan/api/MyInterface$C;Ldev/lankydan/api/MyInterface$D;Ldev/lankydan/api/MyInterface$E;ILjava/lang/Object;)V
    ALOAD 7
    IFNULL L0
    NEW java/lang/UnsupportedOperationException
    DUP
    LDC "Super calls with default arguments not supported in this target, function: function"
    INVOKESPECIAL java/lang/UnsupportedOperationException.<init> (Ljava/lang/String;)V
    ATHROW
   L0
    ILOAD 6
    ICONST_1
    IAND
    IFEQ L1
   L2
    LINENUMBER 5 L2
    NEW dev/lankydan/api/MyInterface$A
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$A.<init> ()V
    ASTORE 1
   L1
    ILOAD 6
    ICONST_2
    IAND
    IFEQ L3
    NEW dev/lankydan/api/MyInterface$B
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$B.<init> ()V
    ASTORE 2
   L3
    ILOAD 6
    ICONST_4
    IAND
    IFEQ L4
    NEW dev/lankydan/api/MyInterface$C
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$C.<init> ()V
    ASTORE 3
   L4
    ILOAD 6
    BIPUSH 8
    IAND
    IFEQ L5
    NEW dev/lankydan/api/MyInterface$D
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$D.<init> ()V
    ASTORE 4
   L5
    ILOAD 6
    BIPUSH 16
    IAND
    IFEQ L6
    NEW dev/lankydan/api/MyInterface$E
    DUP
    INVOKESPECIAL dev/lankydan/api/MyInterface$E.<init> ()V
    ASTORE 5
   L6
    ALOAD 0
    ALOAD 1
    ALOAD 2
    ALOAD 3
    ALOAD 4
    ALOAD 5
    INVOKEINTERFACE dev/lankydan/api/MyInterface.function (Ldev/lankydan/api/MyInterface$A;Ldev/lankydan/api/MyInterface$B;Ldev/lankydan/api/MyInterface$C;Ldev/lankydan/api/MyInterface$D;Ldev/lankydan/api/MyInterface$E;)V (itf)
    RETURN
    MAXSTACK = 6
    MAXLOCALS = 8

  @Lkotlin/Metadata;(mv={1, 4, 1}, bv={1, 0, 3}, k=3)
  // access flags 0x19
  public final static INNERCLASS dev/lankydan/api/MyInterface$DefaultImpls dev/lankydan/api/MyInterface DefaultImpls
  // compiled from: MyInterface.kt
}
```

It's quite likely that most of this doesn't make sense. I'm not trying to be patronising, I also don't _really_ know how to read Kotlin/Java/JVM bytecode but we can still extract some information from it.

Firstly, an alternative version of `MyInterface` was generated, `dev/lankydan/api/MyInterface$DefaultImpls`. I haven't shown all the bytecode, but if I did you would see `dev/lankydan/api/MyInterface` does exist and is separate from the _default_ version.

Secondly, a `synthetic` function was placed inside the previously mentioned `MyInterface$DefaultImpls` with arguments that don't exactly match those of the original version in `MyInterface`. If you look more carefully, you'll notice that the first argument is an instance of `MyInterface` and is followed by the same arguments defined in the Kotlin function. Although that is not entirely true, there are two extra arguments, an `int` and an `Object` (this can be seen in `ILjava/lang/Object;` where the `I` represents the `int` and `Ljava/lang/Object` speaks for itself).

The next question is why are these last two arguments there.

If you can understand the bytecode above, then maybe you've been able to figure out why they're there. For the rest of us mortal beings though, I have added the decompiled version that shows it as Java code below:

```java
public static final class DefaultImpls {
  // $FF: synthetic method
  public static void function$default(MyInterface var0, MyInterface.A var1, MyInterface.B var2, 
  MyInterface.C var3, MyInterface.D var4, MyInterface.E var5, int var6, Object var7) {
    if (var7 != null) {
      throw new UnsupportedOperationException("Super calls with default arguments not supported in this target, function: function");
    } else {
      if ((var6 & 1) != 0) {
        var1 = new MyInterface.A();
      }

      if ((var6 & 2) != 0) {
        var2 = new MyInterface.B();
      }

      if ((var6 & 4) != 0) {
        var3 = new MyInterface.C();
      }

      if ((var6 & 8) != 0) {
        var4 = new MyInterface.D();
      }

      if ((var6 & 16) != 0) {
        var5 = new MyInterface.E();
      }

      var0.function(var1, var2, var3, var4, var5);
    }
  }
}
```

From this version, we can now see how the `int` and `Object` are being used.

- The `Object` - From what I could find out, the `Object` is not actually used as yet. Suposidly, this `Object` will be used for adding `super` calls with default values some time in the future. Here are a few links that indicate this - [StackOverflow](https://stackoverflow.com/questions/39733830/default-arguments-vs-overloads-when-to-use-which/39748921#39748921), [StackOverflow](https://stackoverflow.com/questions/39733830/default-arguments-vs-overloads-when-to-use-which/39748921#39748921) and [Jetbrains' YouTrack](https://youtrack.jetbrains.com/issue/KT-15414) (currently 4 years old).

- The `int` - Determines which arguments use their default values. This is done by executing a bitwise AND (`&`) against the `int` and number increasing in powers of 2 (to represent binary numbers with a leading 1, e.g. 2 = `10` and 16 = `10000`). The `int` itself is determined by the call-site depending on which arguments are passed into the function. For example:

  ```kotlin
  // Kotlin call-site
  myInterface.function(b = MyInterface.B(), c = MyInterface.C())
  ```

  ```java
  // Decompiled code of the call-site
  DefaultImpls.function$default(myInterface, (A)null, new B(), new C(), (D)null, (E)null, 25, (Object)null);
  ```

  The compiler determines that 25 (`11001`) will be passed in. Let's quickly do the bitwise operations to see which default values are used, I've also put an example below and a link to [Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation) incase you're interested in how the bitwise AND works (I haven't linked to Wikipedia for a while!):

  ```
  11001 AND
  00001
  -----
  00001 = 1
  ```

  Below are the operations matching the decompiled code:

  - `25 & 1` = 1
  - `25 & 2` = 0
  - `25 & 4` = 0
  - `25 & 8` = 1
  - `25 & 16` = 1

  These results match up to what we expect. The decompiled code shows that if the result of the bitwise AND returns anything other than 0, then a default value will be supplied. For the call-site above, this means that `A`, `D` and `E` all receive default values, which correctly matches the Kotlin code.

Finally, as seen in the decompiled code, now that all the `var(n)`s are set (with passed in or default values) they are passed into the _real_ function. Thus reaching the end of the process.

Hopefully that all made sense, if not, give it another read. If it still doesn't then you can blame me for failing to explain it well enough. Anyway, we will need this knowledge in the next section to understand how Kotlin's default arguments affect backwards compatibility.

## Why this affects backwards compatibility

## What can be done about it
